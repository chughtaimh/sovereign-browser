<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sovereign Browser</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --tab-bar-height: 40px;
            /* CONSTANT */
            --toolbar-bg: #2d2d2d;
            --input-bg: #1e1e1e;
            --input-border: #4a4a4a;
            --text-color: #e0e0e0;
            --accent-color: #0a84ff;
            --accent-glow: rgba(10, 132, 255, 0.3);
            --dropdown-bg: rgba(45, 45, 45, 0.95);
            --dropdown-hover: #3a3a3a;
            --ghost-color: #808080;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            font-size: 13px;
        }

        #toolbar {
            height: 56px;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(to bottom, #3a3a3a, #2d2d2d);
            gap: 8px;
            border-bottom: 1px solid #1a1a1a;
            -webkit-app-region: drag;
            position: relative;
            z-index: 100;
        }

        /* Input Container relative for dropdown positioning */
        #input-container {
            flex-grow: 1;
            position: relative;
            -webkit-app-region: no-drag;
            height: 32px;
        }

        .url-input-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
        }

        input {
            width: 100%;
            height: 100%;
            padding: 0 12px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            outline: none;
            font-size: 13px;
            background: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            /* Ensure input text is above ghost text if we use overlay method, 
               but here we might use value manipulation or a span behind. 
               Let's use the 'transparent background' with span behind approach 
               OR just standard input and managing selection for ghost text.
               Standard input with selection is more robust for 'Tab' behavior.
            */
            z-index: 2;
            position: relative;
            background: transparent;
            /* allows ghost to show through if we used underlay */
            background-color: var(--input-bg);
            /* Opaque for now */
        }

        input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        /* Ghost Text Overlay (Visual only) */
        #url-ghost {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 0 13px;
            /* match input padding + border rough adjustment */
            display: flex;
            align-items: center;
            color: var(--ghost-color);
            pointer-events: none;
            z-index: 3;
            /* On top of input? No, input text must be visible. */
            /* 
               Actually, the best ghost text is usually: 
               user types "goo", ghost shows "gle.com" right after cursor.
               Implementing that strictly with HTML inputs is hard.
               Easier approach: 
               Input value = "google.com", Selection = "gle.com".
               Visual style matches "ghost" if selected.
            */
            display: none;
            /* Hidden unless we go for custom rendering */
            white-space: pre;
            overflow: hidden;
        }

        /* Autocomplete Dropdown - REMOVED (Moved to separate window) */

        .suggestion-item {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            color: #ccc;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item.selected,
        .suggestion-item:hover {
            background: var(--dropdown-hover);
            color: #fff;
        }

        .suggestion-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: #444;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .suggestion-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1;
        }

        .suggestion-title {
            font-weight: 500;
            color: #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-url {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .match-highlight {
            color: #fff;
            font-weight: 700;
        }

        button {
            -webkit-app-region: no-drag;
            background: #4a4a4a;
            border: 1px solid #5a5a5a;
            color: #e0e0e0;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        button:hover {
            background: #5a5a5a;
            border-color: #6a6a6a;
        }

        button:active {
            background: #3a3a3a;
        }

        button:active {
            background: #3a3a3a;
        }

        /* --- Tab Bar Styles --- */
        #tab-bar {
            height: var(--tab-bar-height);
            /* 40px */
            background: #1e1e1e;
            /* Match root bg */
            display: flex;
            align-items: flex-end;
            padding: 0 10px;
            padding-left: 80px;
            /* PADDING FOR TRAFFIC LIGHTS (Mac) */
            /* Padding for aesthetics */
            padding-top: 4px;
            /* Space above tabs */
            gap: 4px;
            -webkit-app-region: drag;
            /* THE RUNWAY: Entire strip is draggable */
            overflow-x: auto;
            scrollbar-width: none;
            /* Hide scrollbar */
        }

        #tab-bar::-webkit-scrollbar {
            display: none;
        }

        .tab {
            height: 32px;
            /* Leaves 8px top for drag */
            background: #2d2d2d;
            border-radius: 8px 8px 0 0;
            padding: 0 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            max-width: 240px;
            flex: 1;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            -webkit-app-region: no-drag;
            /* HOLES: Tabs absorb clicks */
            transition: background 0.1s;
            position: relative;
            border: 1px solid transparent;
            border-bottom: none;
            user-select: none;
        }

        .tab:hover {
            background: #3a3a3a;
        }

        .tab.active {
            background: #3a3a3a;
            /* Matches toolbar */
            color: #fff;
            position: relative;
            z-index: 10;
        }

        /* Make the toolbar flush with the active tab */
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background: #3a3a3a;
            /* Matches toolbar bg */
        }

        .tab-favicon {
            width: 16px;
            height: 16px;
            background: #444;
            /* Placeholder */
            border-radius: 2px;
            flex-shrink: 0;
        }

        .tab-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tab-close {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #aaa;
            opacity: 0;
            /* Hidden by default */
            transition: all 0.1s;
        }

        .tab-close:hover {
            background: #555;
            color: #fff;
        }

        .tab:hover .tab-close {
            opacity: 1;
        }

        #new-tab-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-app-region: no-drag;
            margin-bottom: 2px;
        }

        #new-tab-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="tab-bar">
        <!-- Tabs injected here -->
        <button id="new-tab-btn" title="New Tab">+</button>
    </div>
    <div id="toolbar">
        <button id="back-btn">&larr;</button>
        <button id="fwd-btn">&rarr;</button>

        <div id="input-container">
            <div class="url-input-wrapper">
                <input type="text" id="url-input" placeholder="Search or enter address" autocomplete="off"
                    spellcheck="false" />
                <div id="url-ghost"></div>
            </div>

            <!-- Dropdown handled by separate window -->
        </div>

        <button id="go-btn" style="width: auto; padding: 0 12px; font-size: 13px;">Go</button>
    </div>

    <script>
        const { invoke } = window.__TAURI__.core;
        const { listen } = window.__TAURI__.event;
        const { getCurrentWebview } = window.__TAURI__.webview;

        const urlInput = document.getElementById('url-input');
        const inputContainer = document.getElementById('input-container');
        const dropdown = document.getElementById('autocomplete-dropdown');
        const ghost = document.getElementById('url-ghost');

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled rejection:', e.reason);
        });

        // Hide dropdown when window loses focus (user switches apps)
        window.addEventListener('blur', () => {
            console.log('[blur] window lost focus, hiding dropdown');
            hideDropdown();
        });

        // State Machine
        const STATE = {
            VIEWING: 'viewing',
            EDITING: 'editing',
            NAVIGATING: 'navigating'
        };
        let inputState = STATE.VIEWING;

        let currentDisplayedUrl = "";
        let selectedIndex = -1;
        let suggestions = [];
        let ghostCandidates = null;
        let searchSeq = 0; // Async guard
        let ignoreNextBlur = false; // Blur shield

        // Debounce Utility
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // ===== Navigation =====
        function navigate(url) {
            let target = url || urlInput.value;
            if (target) {
                inputState = STATE.NAVIGATING;
                invoke('navigate', { url: target });
                hideDropdown();
                // Removed urlInput.blur() to prevent focus fighting
            }
        }

        document.getElementById('go-btn').addEventListener('click', () => navigate());
        document.getElementById('back-btn').addEventListener('click', () => invoke('go_back'));
        document.getElementById('fwd-btn').addEventListener('click', () => invoke('go_forward'));

        // ===== URL Bar Synchronization =====

        listen('url-changed', (event) => {
            const newUrl = event.payload;
            currentDisplayedUrl = newUrl;

            // Only update input if we are in VIEWING mode (or NAVIGATING completed)
            if (inputState === STATE.VIEWING) {
                urlInput.value = newUrl;
            }
        });

        // ===== Tab Management =====
        const tabBar = document.getElementById('tab-bar');
        const newTabBtn = document.getElementById('new-tab-btn');

        newTabBtn.addEventListener('click', () => {
            invoke('create_tab', { url: "https://duckduckgo.com" });
        });

        listen('update-tabs', (event) => {
            const { tabs, activeTabId } = event.payload;
            renderTabs(tabs, activeTabId);
        });

        function renderTabs(tabs, activeId) {
            // Clear existing tabs (keeping the new tab button which is last)
            // Actually, safer to rebuild innerHTML or use insertBefore
            const existingTabs = document.querySelectorAll('.tab');
            existingTabs.forEach(t => t.remove());

            tabs.forEach(tab => {
                const el = document.createElement('div');
                el.className = `tab ${tab.id === activeId ? 'active' : ''}`;

                // Favicon logic (placeholder)
                const favInfo = tab.favicon ? `<img src="${tab.favicon}" class="tab-favicon">` : `<div class="tab-favicon"></div>`;

                el.innerHTML = `
                    ${favInfo}
                    <span class="tab-title">${tab.title || 'New Tab'}</span>
                    <div class="tab-close" title="Close Tab">&times;</div>
                `;

                // Click to Switch
                el.addEventListener('click', (e) => {
                    if (tab.id !== activeId) {
                        invoke('switch_tab', { tabId: tab.id });
                    }
                });

                // Close Button
                const closeBtn = el.querySelector('.tab-close');
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switch
                    invoke('close_tab', { tabId: tab.id });
                });

                // Insert before new tab button
                tabBar.insertBefore(el, newTabBtn);
            });
        }

        // Click Outside to Close
        // Click Outside to Close
        document.addEventListener('click', (e) => {
            const container = document.getElementById('input-container');
            // If we clicked outside input container, reset to viewing
            if (!container.contains(e.target)) {
                // Only reset if we were editing
                if (inputState === STATE.EDITING) {
                    endEditSession(false); // revert
                }
                hideDropdown();
            }
        });

        urlInput.addEventListener('blur', () => {
            // If ignoreNextBlur is set (e.g. interacting with something that shouldn't close), skip
            if (ignoreNextBlur) {
                ignoreNextBlur = false;
                urlInput.focus(); // Reclaim focus
                return;
            }

            // Guard: If window lost focus (moved to another app or dropdown window), DO NOT revert.
            // This allows the user to click away and come back without losing progress.
            if (!document.hasFocus()) {
                return;
            }

            // If we are navigating, do nothing (wait for page load)
            if (inputState === STATE.NAVIGATING) return;

            // Otherwise, end edit session (reverting value)
            requestAnimationFrame(() => {
                if (document.activeElement !== urlInput) {
                    endEditSession(false);
                }
            });
        });

        function startEditSession() {
            inputState = STATE.EDITING;
            urlInput.select();
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            }
        }

        function endEditSession(commit) {
            inputState = STATE.VIEWING;
            hideDropdown();
            if (!commit) {
                urlInput.value = currentDisplayedUrl;
            }
            // If commit, value stays as is until navigation updates it
        }

        // ===== Autocomplete Logic =====

        const doSearch = debounce(async (query) => {
            console.log('[doSearch] called with query:', query);
            if (!query || query.trim() === "") {
                console.log('[doSearch] empty query, clearing');
                suggestions = [];
                hideDropdown();
                return;
            }

            const currentSeq = ++searchSeq;
            console.log('[doSearch] searchSeq:', currentSeq);

            try {
                console.log('[doSearch] invoking search_history...');
                const results = await invoke('search_history', { query: query.trim() });
                console.log('[doSearch] search_history returned:', results);

                // Guard: If a newer search started, ignore this result
                if (currentSeq !== searchSeq) {
                    console.log('[doSearch] stale result, ignoring');
                    return;
                }

                suggestions = results.map(r => ({
                    ...r,
                    type: 'history'
                }));

                // Add DuckDuckGo fallback
                suggestions.push({
                    type: 'search',
                    title: `Search DuckDuckGo for "${query}"`,
                    url: query, // will be parsed by backend
                    score: 0
                });

                console.log('[doSearch] suggestions prepared:', suggestions.length);

                // Reset selection on new search
                selectedIndex = -1;

                await renderDropdown();
                handleGhostText(query, results);
            } catch (e) {
                console.error("[doSearch] ERROR:", e);
            }
        }, 100);

        function handleGhostText(query, results) {
            if (results.length > 0 && results[0].is_ghost_candidate) {
                ghostCandidates = results[0].url;
            } else {
                ghostCandidates = null;
            }
        }

        async function updateDropdownBounds() {
            const rect = inputContainer.getBoundingClientRect();
            // We send LOGICAL coordinates to Rust. Rust now handles the scale factor.
            await invoke('set_dropdown_bounds', {
                x: rect.left,
                y: rect.bottom, // Align to bottom of input container
                width: rect.width,
                height: 300 // Max height logical
            });
        }

        async function renderDropdown() {
            console.log('[renderDropdown] called, suggestions.length:', suggestions.length);
            if (suggestions.length === 0) {
                console.log('[renderDropdown] no suggestions, hiding');
                hideDropdown();
                return;
            }

            try {
                // 1. Set Bounds First
                console.log('[renderDropdown] setting bounds...');
                await updateDropdownBounds();
                console.log('[renderDropdown] bounds set, now calling update_dropdown...');

                // 2. Update Content
                console.log('[dropdown] invoking update_dropdown', { count: suggestions.length, selectedIndex });
                await invoke('update_dropdown', {
                    query: urlInput.value,
                    results: suggestions,
                    selectedIndex: selectedIndex
                });
                console.log('[renderDropdown] update_dropdown completed successfully');
            } catch (e) {
                console.error('[renderDropdown] ERROR:', e);
            }
        }

        // Just trigger render on selection change
        function updateSelection() {
            renderDropdown();
        }

        async function hideDropdown() {
            selectedIndex = -1;
            await invoke('update_dropdown', { query: '', results: [], selectedIndex: -1 });
        }

        // ===== Input Event Listeners =====

        // ===== Input Event Listeners =====

        urlInput.addEventListener('input', (e) => {
            if (inputState !== STATE.EDITING) inputState = STATE.EDITING;

            // Always show dropdown if text exists
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            } else {
                hideDropdown();
            }
        });

        // Show dropdown on focus if content exists
        urlInput.addEventListener('focus', () => {
            startEditSession();
        });

        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex + 1) % suggestions.length;
                    updateSelection();
                    // Do NOT navigate, only highlight
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
                    updateSelection();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && selectedIndex < suggestions.length) {
                    navigate(suggestions[selectedIndex].url);
                } else {
                    navigate();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                endEditSession(false); // Revert and blur
                urlInput.blur();
            } else if (e.key === 'Tab') {
                if (suggestions.length > 0 || ghostCandidates) {
                    e.preventDefault();
                    // Tab behavior: Auto-complete ghost text or cycle?
                    // Standard: Tab moves focus. We might want to keep that if no ghost text.
                    // If ghost text exists, accept it.
                    if (ghostCandidates) {
                        urlInput.value = ghostCandidates;
                        ghostCandidates = null;
                        doSearch(urlInput.value);
                    } else if (suggestions.length > 0 && selectedIndex >= 0) {
                        // If item selected, fill it
                        urlInput.value = suggestions[selectedIndex].url;
                        doSearch(urlInput.value);
                    }
                }
            }
        });

        // ===== Listen for Native Focus Event =====
        // ===== Listen for Native Focus Event =====
        listen('focus-url-bar', async () => {
            await getCurrentWebview().setFocus();
            requestAnimationFrame(() => {
                inputState = STATE.EDITING; // Force editing mode
                urlInput.focus({ preventScroll: true });
                urlInput.select();
                // Check if we need to show dropdown
                if (urlInput.value.trim().length > 0) {
                    doSearch(urlInput.value);
                }
            });
        });

        // ===== Content Focus Event (from Rust) =====
        listen('content-focused', () => {
            // Content received click/focus
            if (inputState === STATE.EDITING) {
                endEditSession(false);
            }
            hideDropdown();
        });

        // ===== Suggestion Prompt (Existing) =====
        listen('show-suggestion-prompt', async () => {
            await getCurrentWebview().setFocus();
            setTimeout(async () => {
                const suggestion = prompt('üí° Leave a suggestion for Sovereign Browser:\n\nShare your ideas, feature requests, or any feedback to help us improve.');
                if (suggestion && suggestion.trim()) {
                    try {
                        await invoke('save_suggestion', { text: suggestion.trim() });
                        alert('‚úÖ Thank you! Your suggestion has been saved.');
                    } catch (e) {
                        alert('‚ùå Failed to save suggestion: ' + e);
                    }
                }
            }, 50);
        });
    </script>
</body>

</html>