<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sovereign Browser</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --toolbar-bg: #2d2d2d;
            --input-bg: #1e1e1e;
            --input-border: #4a4a4a;
            --text-color: #e0e0e0;
            --accent-color: #0a84ff;
            --accent-glow: rgba(10, 132, 255, 0.3);
            --dropdown-bg: rgba(45, 45, 45, 0.95);
            --dropdown-hover: #3a3a3a;
            --ghost-color: #808080;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            font-size: 13px;
        }

        #toolbar {
            height: 56px;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(to bottom, #3a3a3a, #2d2d2d);
            gap: 8px;
            border-bottom: 1px solid #1a1a1a;
            -webkit-app-region: drag;
            position: relative;
            z-index: 100;
        }

        /* Input Container relative for dropdown positioning */
        #input-container {
            flex-grow: 1;
            position: relative;
            -webkit-app-region: no-drag;
            height: 32px;
        }

        .url-input-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
        }

        input {
            width: 100%;
            height: 100%;
            padding: 0 12px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            outline: none;
            font-size: 13px;
            background: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            /* Ensure input text is above ghost text if we use overlay method, 
               but here we might use value manipulation or a span behind. 
               Let's use the 'transparent background' with span behind approach 
               OR just standard input and managing selection for ghost text.
               Standard input with selection is more robust for 'Tab' behavior.
            */
            z-index: 2;
            position: relative;
            background: transparent;
            /* allows ghost to show through if we used underlay */
            background-color: var(--input-bg);
            /* Opaque for now */
        }

        input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        /* Ghost Text Overlay (Visual only) */
        #url-ghost {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 0 13px;
            /* match input padding + border rough adjustment */
            display: flex;
            align-items: center;
            color: var(--ghost-color);
            pointer-events: none;
            z-index: 3;
            /* On top of input? No, input text must be visible. */
            /* 
               Actually, the best ghost text is usually: 
               user types "goo", ghost shows "gle.com" right after cursor.
               Implementing that strictly with HTML inputs is hard.
               Easier approach: 
               Input value = "google.com", Selection = "gle.com".
               Visual style matches "ghost" if selected.
            */
            display: none;
            /* Hidden unless we go for custom rendering */
            white-space: pre;
            overflow: hidden;
        }

        /* Autocomplete Dropdown - REMOVED (Moved to separate window) */

        .suggestion-item {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            color: #ccc;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item.selected,
        .suggestion-item:hover {
            background: var(--dropdown-hover);
            color: #fff;
        }

        .suggestion-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: #444;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .suggestion-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1;
        }

        .suggestion-title {
            font-weight: 500;
            color: #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-url {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .match-highlight {
            color: #fff;
            font-weight: 700;
        }

        button {
            -webkit-app-region: no-drag;
            background: #4a4a4a;
            border: 1px solid #5a5a5a;
            color: #e0e0e0;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        button:hover {
            background: #5a5a5a;
            border-color: #6a6a6a;
        }

        button:active {
            background: #3a3a3a;
        }
    </style>
</head>

<body>
    <div id="toolbar">
        <button id="back-btn">&larr;</button>
        <button id="fwd-btn">&rarr;</button>

        <div id="input-container">
            <div class="url-input-wrapper">
                <input type="text" id="url-input" placeholder="Search or enter address" autocomplete="off"
                    spellcheck="false" />
                <div id="url-ghost"></div>
            </div>

            <!-- Dropdown handled by separate window -->
        </div>

        <button id="go-btn" style="width: auto; padding: 0 12px; font-size: 13px;">Go</button>
    </div>

    <script>
        const { invoke } = window.__TAURI__.core;
        const { listen } = window.__TAURI__.event;
        const { getCurrentWebview } = window.__TAURI__.webview;

        const urlInput = document.getElementById('url-input');
        const inputContainer = document.getElementById('input-container');
        const dropdown = document.getElementById('autocomplete-dropdown');
        const ghost = document.getElementById('url-ghost');

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled rejection:', e.reason);
        });

        // State Machine
        const STATE = {
            VIEWING: 'viewing',
            EDITING: 'editing',
            NAVIGATING: 'navigating'
        };
        let inputState = STATE.VIEWING;

        let currentDisplayedUrl = "";
        let selectedIndex = -1;
        let suggestions = [];
        let ghostCandidates = null;
        let searchSeq = 0; // Async guard
        let ignoreNextBlur = false; // Blur shield

        // Debounce Utility
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // ===== Navigation =====
        function navigate(url) {
            let target = url || urlInput.value;
            if (target) {
                inputState = STATE.NAVIGATING;
                invoke('navigate', { url: target });
                hideDropdown();
                // Removed urlInput.blur() to prevent focus fighting
            }
        }

        document.getElementById('go-btn').addEventListener('click', () => navigate());
        document.getElementById('back-btn').addEventListener('click', () => invoke('go_back'));
        document.getElementById('fwd-btn').addEventListener('click', () => invoke('go_forward'));

        // ===== URL Bar Synchronization =====

        listen('url-changed', (event) => {
            const newUrl = event.payload;
            currentDisplayedUrl = newUrl;

            // Only update input if we are in VIEWING mode (or NAVIGATING completed)
            if (inputState === STATE.VIEWING) {
                urlInput.value = newUrl;
            }
        });

        // Click Outside to Close
        // Click Outside to Close
        document.addEventListener('click', (e) => {
            const container = document.getElementById('input-container');
            // If we clicked outside input container, reset to viewing
            if (!container.contains(e.target)) {
                // Only reset if we were editing
                if (inputState === STATE.EDITING) {
                    endEditSession(false); // revert
                }
                hideDropdown();
            }
        });

        urlInput.addEventListener('blur', () => {
            // If ignoreNextBlur is set (e.g. interacting with something that shouldn't close), skip
            if (ignoreNextBlur) {
                ignoreNextBlur = false;
                urlInput.focus(); // Reclaim focus
                return;
            }

            // Guard: If window lost focus (moved to another app or dropdown window), DO NOT revert.
            // This allows the user to click away and come back without losing progress.
            if (!document.hasFocus()) {
                return;
            }

            // If we are navigating, do nothing (wait for page load)
            if (inputState === STATE.NAVIGATING) return;

            // Otherwise, end edit session (reverting value)
            requestAnimationFrame(() => {
                if (document.activeElement !== urlInput) {
                    endEditSession(false);
                }
            });
        });

        function startEditSession() {
            inputState = STATE.EDITING;
            urlInput.select();
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            }
        }

        function endEditSession(commit) {
            inputState = STATE.VIEWING;
            hideDropdown();
            if (!commit) {
                urlInput.value = currentDisplayedUrl;
            }
            // If commit, value stays as is until navigation updates it
        }

        // ===== Autocomplete Logic =====

        const doSearch = debounce(async (query) => {
            if (!query || query.trim() === "") {
                suggestions = [];
                hideDropdown();
                return;
            }

            const currentSeq = ++searchSeq;

            try {
                const results = await invoke('search_history', { query: query.trim() });

                // Guard: If a newer search started, ignore this result
                if (currentSeq !== searchSeq) return;

                suggestions = results.map(r => ({
                    ...r,
                    type: 'history'
                }));

                // Add DuckDuckGo fallback
                suggestions.push({
                    type: 'search',
                    title: `Search DuckDuckGo for "${query}"`,
                    url: query, // will be parsed by backend
                    score: 0
                });

                // Reset selection on new search
                selectedIndex = -1;

                await renderDropdown();
                handleGhostText(query, results);
            } catch (e) {
                console.error("Search failed", e);
            }
        }, 100);

        function handleGhostText(query, results) {
            if (results.length > 0 && results[0].is_ghost_candidate) {
                ghostCandidates = results[0].url;
            } else {
                ghostCandidates = null;
            }
        }

        async function updateDropdownBounds() {
            const rect = inputContainer.getBoundingClientRect();
            // We send LOGICAL coordinates to Rust. Rust now handles the scale factor.
            await invoke('set_dropdown_bounds', {
                x: rect.left,
                y: rect.bottom, // Align to bottom of input container
                width: rect.width,
                height: 300 // Max height logical
            });
        }

        async function renderDropdown() {
            if (suggestions.length === 0) {
                hideDropdown();
                return;
            }

            // 1. Set Bounds First
            await updateDropdownBounds();

            // 2. Update Content
            console.log('[dropdown] invoking update_dropdown', { count: suggestions.length, selectedIndex });
            await invoke('update_dropdown', {
                query: urlInput.value,
                results: suggestions,
                selected_index: selectedIndex
            });
        }

        // Just trigger render on selection change
        function updateSelection() {
            renderDropdown();
        }

        async function hideDropdown() {
            selectedIndex = -1;
            await invoke('update_dropdown', { query: '', results: [], selected_index: -1 });
        }

        // ===== Input Event Listeners =====

        // ===== Input Event Listeners =====

        urlInput.addEventListener('input', (e) => {
            if (inputState !== STATE.EDITING) inputState = STATE.EDITING;

            // Always show dropdown if text exists
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            } else {
                hideDropdown();
            }
        });

        // Show dropdown on focus if content exists
        urlInput.addEventListener('focus', () => {
            startEditSession();
        });

        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex + 1) % suggestions.length;
                    updateSelection();
                    // Do NOT navigate, only highlight
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
                    updateSelection();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && selectedIndex < suggestions.length) {
                    navigate(suggestions[selectedIndex].url);
                } else {
                    navigate();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                endEditSession(false); // Revert and blur
                urlInput.blur();
            } else if (e.key === 'Tab') {
                if (suggestions.length > 0 || ghostCandidates) {
                    e.preventDefault();
                    // Tab behavior: Auto-complete ghost text or cycle?
                    // Standard: Tab moves focus. We might want to keep that if no ghost text.
                    // If ghost text exists, accept it.
                    if (ghostCandidates) {
                        urlInput.value = ghostCandidates;
                        ghostCandidates = null;
                        doSearch(urlInput.value);
                    } else if (suggestions.length > 0 && selectedIndex >= 0) {
                        // If item selected, fill it
                        urlInput.value = suggestions[selectedIndex].url;
                        doSearch(urlInput.value);
                    }
                }
            }
        });

        // ===== Listen for Native Focus Event =====
        // ===== Listen for Native Focus Event =====
        listen('focus-url-bar', async () => {
            await getCurrentWebview().setFocus();
            requestAnimationFrame(() => {
                inputState = STATE.EDITING; // Force editing mode
                urlInput.focus({ preventScroll: true });
                urlInput.select();
                // Check if we need to show dropdown
                if (urlInput.value.trim().length > 0) {
                    doSearch(urlInput.value);
                }
            });
        });

        // ===== Content Focus Event (from Rust) =====
        listen('content-focused', () => {
            // Content received click/focus
            if (inputState === STATE.EDITING) {
                endEditSession(false);
            }
            hideDropdown();
        });

        // ===== Suggestion Prompt (Existing) =====
        listen('show-suggestion-prompt', async () => {
            await getCurrentWebview().setFocus();
            setTimeout(async () => {
                const suggestion = prompt('üí° Leave a suggestion for Sovereign Browser:\n\nShare your ideas, feature requests, or any feedback to help us improve.');
                if (suggestion && suggestion.trim()) {
                    try {
                        await invoke('save_suggestion', { text: suggestion.trim() });
                        alert('‚úÖ Thank you! Your suggestion has been saved.');
                    } catch (e) {
                        alert('‚ùå Failed to save suggestion: ' + e);
                    }
                }
            }, 50);
        });
    </script>
</body>

</html>