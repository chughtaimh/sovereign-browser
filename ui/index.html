<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sovereign Browser</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --tab-bar-height: 40px;
            /* CONSTANT */
            --toolbar-bg: #2d2d2d;
            --input-bg: #1e1e1e;
            --input-border: #4a4a4a;
            --text-color: #e0e0e0;
            --accent-color: #0a84ff;
            --accent-glow: rgba(10, 132, 255, 0.3);
            --dropdown-bg: rgba(45, 45, 45, 0.95);
            --dropdown-hover: #3a3a3a;
            --ghost-color: #808080;
        }

        /* Light Theme - Comprehensive overrides */
        body.light-theme {
            --bg-color: #f5f5f5;
            --toolbar-bg: #e8e8e8;
            --input-bg: #ffffff;
            --input-border: #c0c0c0;
            --text-color: #333333;
            --dropdown-bg: rgba(255, 255, 255, 0.98);
            --dropdown-hover: #e8e8e8;
            --ghost-color: #999999;
        }

        /* Light theme: Override hardcoded toolbar gradient */
        body.light-theme #toolbar {
            background: linear-gradient(to bottom, #f0f0f0, #e0e0e0);
            border-bottom: 1px solid #c0c0c0;
        }

        /* Light theme: Override tab bar */
        body.light-theme #tab-bar {
            background: #e8e8e8;
        }

        /* Light theme: Tabs */
        body.light-theme .tab {
            background: #d8d8d8;
            color: #333;
        }

        body.light-theme .tab:hover {
            background: #c8c8c8;
        }

        body.light-theme .tab.active {
            background: #f5f5f5;
            color: #000;
        }

        /* Light theme: Buttons */
        body.light-theme button {
            background: #e0e0e0;
            border: 1px solid #c0c0c0;
            color: #333;
        }

        body.light-theme button:hover {
            background: #d0d0d0;
            border-color: #b0b0b0;
        }

        body.light-theme button:active {
            background: #c0c0c0;
        }

        /* Light theme: Suggestions */
        body.light-theme .suggestion-item {
            color: #333;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        body.light-theme .suggestion-item.selected,
        body.light-theme .suggestion-item:hover {
            background: #e0e0e0;
            color: #000;
        }

        body.light-theme .suggestion-icon {
            background: #d0d0d0;
        }

        body.light-theme .suggestion-title {
            color: #222;
        }

        body.light-theme .suggestion-url {
            color: #666;
        }

        body.light-theme .match-highlight {
            color: #000;
        }

        /* Compact Mode */
        body.compact #toolbar {
            height: 55px;
            padding: 4px 8px;
        }

        body.compact #input-container {
            height: 28px;
        }

        body.compact .nav-button {
            width: 28px;
            height: 28px;
            font-size: 12px;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            font-size: 13px;
        }

        #toolbar {
            height: 56px;
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(to bottom, #3a3a3a, #2d2d2d);
            gap: 8px;
            border-bottom: 1px solid #1a1a1a;
            position: relative;
            z-index: 100;
        }

        /* Input Container relative for dropdown positioning */
        #input-container {
            flex-grow: 1;
            position: relative;
            height: 32px;
        }

        .url-input-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
        }

        input {
            width: 100%;
            height: 100%;
            padding: 0 12px;
            border-radius: 6px;
            border: 1px solid var(--input-border);
            outline: none;
            font-size: 13px;
            background: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.15s ease, box-shadow 0.15s ease;
            /* Ensure input text is above ghost text if we use overlay method, 
               but here we might use value manipulation or a span behind. 
               Let's use the 'transparent background' with span behind approach 
               OR just standard input and managing selection for ghost text.
               Standard input with selection is more robust for 'Tab' behavior.
            */
            z-index: 2;
            position: relative;
            background: transparent;
            /* allows ghost to show through if we used underlay */
            background-color: var(--input-bg);
            /* Opaque for now */
        }

        input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        /* Ghost Text Overlay (Visual only) */
        #url-ghost {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 0 13px;
            /* match input padding + border rough adjustment */
            display: flex;
            align-items: center;
            color: var(--ghost-color);
            pointer-events: none;
            z-index: 3;
            /* On top of input? No, input text must be visible. */
            /* 
               Actually, the best ghost text is usually: 
               user types "goo", ghost shows "gle.com" right after cursor.
               Implementing that strictly with HTML inputs is hard.
               Easier approach: 
               Input value = "google.com", Selection = "gle.com".
               Visual style matches "ghost" if selected.
            */
            display: none;
            /* Hidden unless we go for custom rendering */
            white-space: pre;
            overflow: hidden;
        }

        /* Autocomplete Dropdown - REMOVED (Moved to separate window) */

        .suggestion-item {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
            color: #ccc;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item.selected,
        .suggestion-item:hover {
            background: var(--dropdown-hover);
            color: #fff;
        }

        .suggestion-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: #444;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .suggestion-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-grow: 1;
        }

        .suggestion-title {
            font-weight: 500;
            color: #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-url {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .match-highlight {
            color: #fff;
            font-weight: 700;
        }

        button {
            background: #4a4a4a;
            border: 1px solid #5a5a5a;
            color: #e0e0e0;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        button:hover {
            background: #5a5a5a;
            border-color: #6a6a6a;
        }

        button:active {
            background: #3a3a3a;
        }

        button:active {
            background: #3a3a3a;
        }

        /* --- Tab Bar Styles --- */
        #tab-bar {
            height: var(--tab-bar-height);
            /* 40px */
            background: #1e1e1e;
            /* Match root bg */
            display: flex;
            align-items: flex-end;
            padding: 0 10px;
            padding-left: 80px;
            /* PADDING FOR TRAFFIC LIGHTS (Mac) */
            /* Padding for aesthetics */
            padding-top: 4px;
            /* Space above tabs */
            gap: 4px;
            /* THE RUNWAY: Entire strip is draggable via JS handler */
            overflow-x: auto;
            scrollbar-width: none;
            /* Hide scrollbar */
        }

        #tab-bar::-webkit-scrollbar {
            display: none;
        }

        .tab {
            height: 32px;
            /* Leaves 8px top for drag */
            background: #2d2d2d;
            border-radius: 8px 8px 0 0;
            padding: 0 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            max-width: 240px;
            flex: 1;
            color: #ccc;
            font-size: 12px;
            cursor: grab;
            /* Show grab cursor for draggable tabs */
            transition: background 0.1s;
            position: relative;
            border: 1px solid transparent;
            border-bottom: none;
            user-select: none;
        }

        .tab:hover {
            background: #3a3a3a;
        }

        .tab.active {
            background: #3a3a3a;
            /* Matches toolbar */
            color: #fff;
            position: relative;
            z-index: 10;
            border-top: 2px solid #007AFF;
            /* Blue accent to indicate active tab */
        }

        /* Make the toolbar flush with the active tab */
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background: #3a3a3a;
            /* Matches toolbar bg */
        }

        .tab-favicon {
            width: 16px;
            height: 16px;
            background: #444;
            /* Placeholder */
            border-radius: 2px;
            flex-shrink: 0;
            pointer-events: none;
            /* Allow drag events to pass through to parent tab */
        }

        .tab-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            pointer-events: none;
            /* Allow drag events to pass through to parent tab */
        }

        .tab-close {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #aaa;
            opacity: 0;
            /* Hidden by default */
            transition: all 0.1s;
            pointer-events: auto;
            /* Keep close button clickable */
        }

        .tab-close:hover {
            background: #555;
            color: #fff;
        }

        .tab:hover .tab-close {
            opacity: 1;
        }

        .tab.dragging {
            cursor: grabbing;
        }

        .tab.drag-over {
            border-left: 2px solid var(--accent-color);
        }

        #new-tab-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2px;
        }

        #new-tab-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="tab-bar">
        <!-- Tabs injected here -->
        <button id="new-tab-btn" title="New Tab">+</button>
    </div>
    <div id="toolbar">
        <button id="back-btn">&larr;</button>
        <button id="fwd-btn">&rarr;</button>

        <div id="input-container">
            <div class="url-input-wrapper">
                <input type="text" id="url-input" placeholder="Search or enter address" autocomplete="off"
                    spellcheck="false" />
                <div id="url-ghost"></div>
            </div>

            <!-- Dropdown handled by separate window -->
        </div>

        <button id="go-btn" style="width: auto; padding: 0 12px; font-size: 13px;">Go</button>
    </div>

    <script>
        const { invoke } = window.__TAURI__.core;
        const { listen } = window.__TAURI__.event;
        const { getCurrentWebview } = window.__TAURI__.webview;
        const { getCurrentWindow } = window.__TAURI__.window;

        document.addEventListener('mousedown', (e) => {
            // 1. Only allow main mouse button (Left Click)
            if (e.button !== 0) return;

            // 2. Allow List: Only drag if the clicked element's ID matches exactly.
            //    This implicitly ignores all buttons, inputs, and tabs.
            //    NOTE: If you have other container divs acting as spacers, add their IDs here.
            const dragTargets = ['toolbar', 'tab-bar', 'input-container'];

            if (dragTargets.includes(e.target.id)) {
                e.preventDefault(); // Stop text cursor flickering
                getCurrentWindow().startDragging();
            }
        });

        const urlInput = document.getElementById('url-input');
        const inputContainer = document.getElementById('input-container');
        const dropdown = document.getElementById('autocomplete-dropdown');
        const ghost = document.getElementById('url-ghost');

        // EXTERNAL LINK HANDLER (Hot Start)
        listen('request-open-url', (event) => {
            console.log('[External Link] Received:', event.payload);

            // Payload is a string URL
            const url = Array.isArray(event.payload) ? event.payload[0] : event.payload;

            if (url && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('file://'))) {
                // UX RULE: External links must ALWAYS open a new tab.
                invoke('create_tab', { url: url });
            }
        });

        // COLD START CHECK: Ask Rust if a URL was passed on app launch
        async function checkLaunchUrl() {
            try {
                const url = await invoke('get_pending_launch_url');
                if (url) {
                    console.log('[Cold Start] URL found:', url);
                    invoke('create_tab', { url: url });
                }
            } catch (e) {
                console.error('[Cold Start] Error checking launch URL:', e);
            }
        }

        // Call immediately
        checkLaunchUrl();

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled rejection:', e.reason);
        });

        // Hide dropdown when window loses focus (user switches apps)
        window.addEventListener('blur', () => {
            console.log('[blur] window lost focus, hiding dropdown');
            hideDropdown();
        });

        // State Machine
        const STATE = {
            VIEWING: 'viewing',
            EDITING: 'editing',
            NAVIGATING: 'navigating'
        };
        let inputState = STATE.VIEWING;

        let currentDisplayedUrl = "";
        let selectedIndex = -1;
        let suggestions = [];
        let ghostCandidates = null;
        let searchSeq = 0; // Async guard
        let ignoreNextBlur = false; // Blur shield

        // Debounce Utility
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // ===== Navigation =====
        function navigate(url) {
            let target = url || urlInput.value;
            if (target) {
                inputState = STATE.NAVIGATING;
                invoke('navigate', { url: target });
                hideDropdown();
                // Removed urlInput.blur() to prevent focus fighting
            }
        }

        document.getElementById('go-btn').addEventListener('click', () => navigate());
        document.getElementById('back-btn').addEventListener('click', () => invoke('go_back'));
        document.getElementById('fwd-btn').addEventListener('click', () => invoke('go_forward'));

        // ===== URL Bar Synchronization =====

        listen('url-changed', (event) => {
            const newUrl = event.payload;
            currentDisplayedUrl = newUrl;

            // Only update input if we are in VIEWING mode (or NAVIGATING completed)
            if (inputState === STATE.VIEWING) {
                urlInput.value = newUrl;
            }
        });

        // ===== Tab Management =====
        const tabBar = document.getElementById('tab-bar');
        const newTabBtn = document.getElementById('new-tab-btn');

        newTabBtn.addEventListener('click', () => {
            invoke('create_tab', { url: "https://duckduckgo.com" });
        });

        // ===== Native macOS Double-Click to Maximize =====
        // Double-click on empty toolbar space to toggle maximize (native macOS behavior)
        const toggleMaximize = async (e) => {
            // Only trigger on empty space (not on tabs, buttons, or interactive elements)
            if (e.target.closest('.tab') || e.target.closest('button') || e.target.closest('input')) {
                return;
            }

            try {
                await invoke('toggle_window_maximize');
            } catch (err) {
                console.error('[Window] Failed to toggle maximize:', err);
            }
        };

        // Add to both tab bar and toolbar for complete coverage
        tabBar.addEventListener('dblclick', toggleMaximize);
        document.getElementById('toolbar').addEventListener('dblclick', toggleMaximize);

        // Track pending tabs update during drag
        let pendingTabsUpdate = null;

        listen('update-tabs', (event) => {
            const { tabs, activeTabId } = event.payload;

            // Don't re-render tabs while dragging (causes stale references and duplicates)
            if (isDragging) {
                console.log('[Tabs] Deferring update-tabs during drag');
                pendingTabsUpdate = { tabs, activeTabId };
                return;
            }

            renderTabs(tabs, activeTabId);
        });

        // Tab Reordering State
        let isDragging = false;
        let draggedTab = null;
        let draggedTabId = null;
        let justFinishedDrag = false;

        function renderTabs(tabs, activeId) {
            // Clear existing tabs (keeping the new tab button which is last)
            // Actually, safer to rebuild innerHTML or use insertBefore
            const existingTabs = document.querySelectorAll('.tab');
            existingTabs.forEach(t => t.remove());

            tabs.forEach(tab => {
                const el = document.createElement('div');
                el.className = `tab ${tab.id === activeId ? 'active' : ''}`;
                el.dataset.tabId = tab.id;

                // Favicon logic (placeholder)
                const favInfo = tab.favicon ? `<img src="${tab.favicon}" class="tab-favicon">` : `<div class="tab-favicon"></div>`;

                el.innerHTML = `
                    ${favInfo}
                    <span class="tab-title">${tab.title || 'New Tab'}</span>
                    <div class="tab-close" title="Close Tab">&times;</div>
                `;

                // Click to Switch
                el.addEventListener('click', (e) => {
                    // Don't switch if we just finished dragging
                    if (justFinishedDrag) {
                        justFinishedDrag = false;
                        return;
                    }

                    if (tab.id !== activeId && !draggedTab && !isDragging) {
                        invoke('switch_tab', { tabId: tab.id });
                    }
                });

                // Close Button
                const closeBtn = el.querySelector('.tab-close');
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switch
                    invoke('close_tab', { tabId: tab.id });
                });

                // Mouse Drag Handler
                el.addEventListener('mousedown', handleMouseDown);

                // Insert before new tab button
                tabBar.insertBefore(el, newTabBtn);
            });
        }

        // ===== Tab Mouse Drag Handlers =====
        let dragStartX = 0;
        let hasDragged = false;

        function handleMouseDown(e) {
            // Ignore clicks on close button
            if (e.target.closest('.tab-close')) return;

            // Prevent text selection during drag
            e.preventDefault();

            draggedTab = e.currentTarget;
            draggedTabId = e.currentTarget.dataset.tabId;
            dragStartX = e.clientX;
            hasDragged = false;

            // Add global listeners
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            console.log('[Tab Drag] Mouse down on:', draggedTabId);
        }

        function handleMouseMove(e) {
            if (!draggedTab) return;

            // Check if we've moved enough to consider this a drag (5px threshold)
            const distance = Math.abs(e.clientX - dragStartX);

            if (!hasDragged && distance > 5) {
                // First time dragging - initialize drag state
                hasDragged = true;
                isDragging = true;
                draggedTab.classList.add('dragging');

                // Switch to the dragged tab
                if (!draggedTab.classList.contains('active')) {
                    invoke('switch_tab', { tabId: draggedTabId });
                }

                console.log('[Tab Drag] Drag started');
            }

            if (!isDragging) return;

            // Find tab under cursor
            const tabs = Array.from(document.querySelectorAll('.tab'));
            const targetTab = tabs.find(tab => {
                if (tab === draggedTab) return false;
                const rect = tab.getBoundingClientRect();
                return e.clientX >= rect.left && e.clientX <= rect.right;
            });

            if (targetTab) {
                const rect = targetTab.getBoundingClientRect();
                const midpoint = rect.left + rect.width / 2;

                // Reorder based on midpoint
                if (e.clientX < midpoint) {
                    tabBar.insertBefore(draggedTab, targetTab);
                } else {
                    tabBar.insertBefore(draggedTab, targetTab.nextSibling);
                }
            }
        }

        function handleMouseUp(e) {
            // Remove global listeners first
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);

            if (hasDragged && isDragging) {
                // Actual drag occurred - send reorder to backend
                draggedTab.classList.remove('dragging');

                const newOrder = Array.from(document.querySelectorAll('.tab')).map(t => t.dataset.tabId);
                console.log('[Tab Drag] Sending new order:', newOrder);

                invoke('reorder_tabs', { newOrder }).then(() => {
                    console.log('[Tab Drag] Backend updated');
                }).catch(err => {
                    console.error('[Tab Drag] Backend failed:', err);
                });

                // Prevent the click handler from firing after a drag
                justFinishedDrag = true;
            }
            // If not dragged, it was just a click - let the click handler deal with it

            // Clean up drag state
            isDragging = false;
            draggedTab = null;
            draggedTabId = null;
            hasDragged = false;

            // Apply any pending tabs update that was deferred during drag
            if (pendingTabsUpdate) {
                console.log('[Tabs] Applying deferred tabs update');
                renderTabs(pendingTabsUpdate.tabs, pendingTabsUpdate.activeTabId);
                pendingTabsUpdate = null;
            }
        }

        // Click Outside to Close
        // Click Outside to Close
        document.addEventListener('click', (e) => {
            const container = document.getElementById('input-container');
            // If we clicked outside input container, reset to viewing
            if (!container.contains(e.target)) {
                // Only reset if we were editing
                if (inputState === STATE.EDITING) {
                    endEditSession(false); // revert
                }
                hideDropdown();
            }
        });

        urlInput.addEventListener('blur', () => {
            // If ignoreNextBlur is set (e.g. interacting with something that shouldn't close), skip
            if (ignoreNextBlur) {
                ignoreNextBlur = false;
                urlInput.focus(); // Reclaim focus
                return;
            }

            // Guard: If window lost focus (moved to another app or dropdown window), DO NOT revert.
            // This allows the user to click away and come back without losing progress.
            if (!document.hasFocus()) {
                return;
            }

            // If we are navigating, do nothing (wait for page load)
            if (inputState === STATE.NAVIGATING) return;

            // Otherwise, end edit session (reverting value)
            requestAnimationFrame(() => {
                if (document.activeElement !== urlInput) {
                    endEditSession(false);
                }
            });
        });

        function startEditSession() {
            inputState = STATE.EDITING;
            urlInput.select();
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            }
        }

        function endEditSession(commit) {
            inputState = STATE.VIEWING;
            hideDropdown();
            if (!commit) {
                urlInput.value = currentDisplayedUrl;
            }
            // If commit, value stays as is until navigation updates it
        }

        // ===== Autocomplete Logic =====

        const doSearch = debounce(async (query) => {
            console.log('[doSearch] called with query:', query);
            if (!query || query.trim() === "") {
                console.log('[doSearch] empty query, clearing');
                suggestions = [];
                hideDropdown();
                return;
            }

            const currentSeq = ++searchSeq;
            console.log('[doSearch] searchSeq:', currentSeq);

            try {
                console.log('[doSearch] invoking search_history...');
                const results = await invoke('search_history', { query: query.trim() });
                console.log('[doSearch] search_history returned:', results);

                // Guard: If a newer search started, ignore this result
                if (currentSeq !== searchSeq) {
                    console.log('[doSearch] stale result, ignoring');
                    return;
                }

                suggestions = results.map(r => ({
                    ...r,
                    type: 'history'
                }));

                // Add DuckDuckGo fallback
                suggestions.push({
                    type: 'search',
                    title: `Search DuckDuckGo for "${query}"`,
                    url: query, // will be parsed by backend
                    score: 0
                });

                console.log('[doSearch] suggestions prepared:', suggestions.length);

                // Reset selection on new search
                selectedIndex = -1;

                await renderDropdown();
                handleGhostText(query, results);
            } catch (e) {
                console.error("[doSearch] ERROR:", e);
            }
        }, 100);

        function handleGhostText(query, results) {
            if (results.length > 0 && results[0].is_ghost_candidate) {
                ghostCandidates = results[0].url;
            } else {
                ghostCandidates = null;
            }
        }

        async function updateDropdownBounds() {
            const rect = inputContainer.getBoundingClientRect();
            // We send LOGICAL coordinates to Rust. Rust now handles the scale factor.
            await invoke('set_dropdown_bounds', {
                x: rect.left,
                y: rect.bottom, // Align to bottom of input container
                width: rect.width,
                height: 300 // Max height logical
            });
        }

        async function renderDropdown() {
            console.log('[renderDropdown] called, suggestions.length:', suggestions.length);
            if (suggestions.length === 0) {
                console.log('[renderDropdown] no suggestions, hiding');
                hideDropdown();
                return;
            }

            try {
                // 1. Set Bounds First
                console.log('[renderDropdown] setting bounds...');
                await updateDropdownBounds();
                console.log('[renderDropdown] bounds set, now calling update_dropdown...');

                // 2. Update Content
                console.log('[dropdown] invoking update_dropdown', { count: suggestions.length, selectedIndex });
                await invoke('update_dropdown', {
                    query: urlInput.value,
                    results: suggestions,
                    selectedIndex: selectedIndex
                });
                console.log('[renderDropdown] update_dropdown completed successfully');
            } catch (e) {
                console.error('[renderDropdown] ERROR:', e);
            }
        }

        // Just trigger render on selection change
        function updateSelection() {
            renderDropdown();
        }

        async function hideDropdown() {
            selectedIndex = -1;
            await invoke('update_dropdown', { query: '', results: [], selectedIndex: -1 });
        }

        // ===== Input Event Listeners =====

        // ===== Input Event Listeners =====

        urlInput.addEventListener('input', (e) => {
            if (inputState !== STATE.EDITING) inputState = STATE.EDITING;

            // Always show dropdown if text exists
            if (urlInput.value.trim().length > 0) {
                doSearch(urlInput.value);
            } else {
                hideDropdown();
            }
        });

        // Show dropdown on focus if content exists
        urlInput.addEventListener('focus', () => {
            startEditSession();
        });

        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex + 1) % suggestions.length;
                    updateSelection();
                    // Do NOT navigate, only highlight
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (suggestions.length > 0) {
                    selectedIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
                    updateSelection();
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && selectedIndex < suggestions.length) {
                    navigate(suggestions[selectedIndex].url);
                } else {
                    navigate();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                endEditSession(false); // Revert and blur
                urlInput.blur();
            } else if (e.key === 'Tab') {
                if (suggestions.length > 0 || ghostCandidates) {
                    e.preventDefault();
                    // Tab behavior: Auto-complete ghost text or cycle?
                    // Standard: Tab moves focus. We might want to keep that if no ghost text.
                    // If ghost text exists, accept it.
                    if (ghostCandidates) {
                        urlInput.value = ghostCandidates;
                        ghostCandidates = null;
                        doSearch(urlInput.value);
                    } else if (suggestions.length > 0 && selectedIndex >= 0) {
                        // If item selected, fill it
                        urlInput.value = suggestions[selectedIndex].url;
                        doSearch(urlInput.value);
                    }
                }
            }
        });

        // ===== Listen for Native Focus Event =====
        // ===== Listen for Native Focus Event =====
        listen('focus-url-bar', async () => {
            // Skip focus during drag operations
            if (isDragging) {
                console.log('[Focus] Skipping URL focus during drag');
                return;
            }

            await getCurrentWebview().setFocus();
            requestAnimationFrame(() => {
                inputState = STATE.EDITING; // Force editing mode
                urlInput.focus({ preventScroll: true });
                urlInput.select();
                // Check if we need to show dropdown
                if (urlInput.value.trim().length > 0) {
                    doSearch(urlInput.value);
                }
            });
        });

        // ===== Content Focus Event (from Rust) =====
        listen('content-focused', () => {
            // Content received click/focus
            if (inputState === STATE.EDITING) {
                endEditSession(false);
            }
            hideDropdown();
        });

        // ===== Suggestion Prompt (Existing) =====
        listen('show-suggestion-prompt', async () => {
            await getCurrentWebview().setFocus();
            setTimeout(async () => {
                const suggestion = prompt('ðŸ’¡ Leave a suggestion for Sovereign Browser:\n\nShare your ideas, feature requests, or any feedback to help us improve.');
                if (suggestion && suggestion.trim()) {
                    try {
                        await invoke('save_suggestion', { text: suggestion.trim() });
                        alert('âœ… Thank you! Your suggestion has been saved.');
                    } catch (e) {
                        alert('âŒ Failed to save suggestion: ' + e);
                    }
                }
            }, 50);
        });

        // ===== Settings Update Event (from Rust) =====
        listen('settings-update', (event) => {
            const settings = event.payload;

            // Apply Theme
            if (settings.theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }

            // Apply Compact Mode
            if (settings.compact_mode) {
                document.body.classList.add('compact');
            } else {
                document.body.classList.remove('compact');
            }
        });

        // ===== Load initial settings on startup =====
        (async () => {
            try {
                const settings = await invoke('get_settings');
                if (settings.theme === 'light') {
                    document.body.classList.add('light-theme');
                }
                if (settings.compact_mode) {
                    document.body.classList.add('compact');
                }
            } catch (e) {
                console.error('Failed to load initial settings:', e);
            }
        })();
    </script>
</body>

</html>